### 1，请说出下列最终的执行结果，并解释为什么
    var a = [];
    for(var i = 0;i < 10;i++){
      a[i] = function(){
        console.log(i)
      }
    }
    a[6]()
    结果为：10。
    i为全局变量，在开始执行前会进行变量提升，等到循环结束后，这是全局变量i的值为10，循环结束后会执行函数，函数中的i经过作用域链找到全局执行上下文中的i，此时的i为10，所以结果从a[0]到a[9]d的结果都是10
### 2，请说出下列最终的执行结果，并解释为什么
    var tmp = 123;
    if(true){
      console.log(tmp);
      let tmp;
    }
    结果：会报错，报tmp没有定义
    块级作用域中，let创建的过程会被提升，初始化未被提升，称为暂时性死区，因此不能再初始化之前访问let声明的变量
### 3，结合ES6新语法，用最简单的方式找出数组中的最小值
    var arr = [12,34,32,89,4]
    let ar=arr=>Math.min(...arr)
    console.log(ar(arr))
### 4，请详细说明var,let,const三种声明变量的方式之间的具体差别
    var是全局变量，在代码执行前会进行变量提升。
    let是局部变量，没有变量提升，只能在当前作用域中使用。
    const是全局变量，有变量提升，但是当变量值确定就不能在进行更改
### 5，请说出下列代码最终输出的结果，并解释为什么
    var a = 10;
    var obj = {
      a:20;
      fn(){
        setTimeout(()=>{
          console.log(this.a)
        })
      }
    }
    obj.fn()
    结果为20。
    代码执行到obj对象的时候，会开辟一片内存空间，让obj指向这片空间，当前obj空间中的a的值为20，然后执行定时器里面的代码。改代码会先在定时器的作用域中找a的值，没有就顺着作用域链条找fn函数作用域中的a，没有就往上找obj作用域中的a，此时a的值为20
### 6，简述symbol类型的用途
    1，如果我们定义一个类，不想让外部直接更改类里面定义的变量的值的话，那就用Symbol类型来定义变量的属性名。
    2，可以用来代替常量，可以保证常量的值的唯一性。
    3，可以定义类的私有属性/方法，Symbol定义的类属性是没有办法被模块外访问到的，可以达到一个私有化的效果。
### 7，说说什么是浅拷贝，什么是深拷贝
    浅拷贝：对于基本类型，直接复制了一份；对于引用类型，拷贝了引用地址；
    深拷贝：不管是基本类型还是引用类型甚至里面的子对象都会直接复制，改变原属性不会影响新属性。
### 8，请简述TypeScript与JavaScript之间的关系
    TypeScript是javascript的超集，ts是强类型的语言，相比于js，ts增加了支持类和模块，静态类型检查。ts项目中完全可以用js代码进行编写，ts代码需要转换成js代码才能在浏览器上运行
### 9，请谈谈你所认为的TypeScript优缺点
    优点：
      1，增强代码的可读性和可维护性，强类型的语言在编译阶段就能发现大部分的错误。
      2，js文件可以直接改成ts文件，可以定义几乎一切类型，ts报错也可以生成js文件。
    缺点：
      1，增加学习成本，需要理解接口(onterfaces)，泛型(generics)，类(class)，枚举类型(enums)。
      2，短期增加开发成本，增加类型定义，但是减少后期的维护成本
### 10，描述应用计数的工作原理和优缺点
    工作原理：当有一个对象A，只要有任意一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计算器就减1。只要对象A的引用计数器的数组为0，就表明对象A不在被引用，这时就会触发V8引擎的会执行垃圾回收机制进行回收。
    优点：实现简单，垃圾对象便于辨识，判定效率高，回收没有延迟性。
    缺点：
      1，需要单独的空间存储计数器，这样就增加了存储空间的开销。
      2，每次复制都需要更新计数器，伴随着加法和减法操作，这增加了时间的消耗。
      3，无法处理循环引用
### 11，描述标记整理算法的工作流程
    分标记和清楚两个阶段完成
    遍历所有对象找标记活动对象
    遍历所有对象清除没有标记对象
    清楚阶段会先执行整理，移动对象位置
    减少碎片化控件，不会立即回收垃圾
### 12，描述V8中新生代存储区垃圾回收的流程
    回收过程采用复制算法+标记整理
    新生代内存区分为二个等大小空间
    使用空间为From，空闲空间为to
    活动对象存储与于from空间
    标记整理后将活动对象拷贝至To
    From与To交换空间完成释放
    拷贝过程中可能出现晋升
    晋升就是将新生代对象移动至老生代
    一轮GC还存活的新生代需要晋升
    To空间的使用率超过25
### 13，描述增量标记算法在何时使用及工作原理
    程序在标记阶段被暂停运行，等待标记完成自动运行，当遇到大块需要标记的对象时，程序需要暂停很长一段时间，对用户体验很不友好，因此采用增量标记，将一大块分解为多个小块进行标记，减少每次程序暂停的时长，优化用户体验。最后标记完成后统一进行回收。